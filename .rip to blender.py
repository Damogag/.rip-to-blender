############################################
#            RIP FILE IMPORTER             #
#
# able to import .rip files generated by ninjaripper into blender
# written in blender 2.76 for ninjaripper 1.3.3

import bpy
import os
import struct

# you might need to change some values here:

dir = "E:/Tools/ninjaripper1.3.3/ripped/_Ripper/26.10.2015_14.32.46/Frames/Frame0000/" #the directory to scan

asig = "0xdeadc0de" #the assumed file signature
aver = 4 #the assumed file version
spos = "POSITION"
snorm = "NORMAL"
types = ["FLOAT","UINT"]

def OMG():
    print("Somethig went horribly wrong...")
    return

def readint(b, i):
    return struct.unpack('I', b[i:i+4])[0]

def readfloat(b, i):
    return struct.unpack('f', b[i:i+4])[0]

def next0(b, i):
    end = i
    test = b[end]
    while(test != 0):
        end += 1
        test = b[end]
    return end

def readstring(b, i):
    return b[i:next0(b, i)].decode("ascii")

def import_ninja_rip(filename, object_name):
    bytes = []
    nfaces = 0
    nverts = 0
    vblocksize = 0
    ntextures = 0
    nshaders = 0 #no function?
    nattr = 0 #values per vert-block
    attributes = [] #name, index, offset, size, element count, types
    pointer = 0
    textures = []
    faces = []
    vdata = []
    vertex_position = []
    vertex_normal = []
    
    with open(filename, mode = "rb") as f:
        bytes = f.read()

    if not bytes: #check if file was copied to memory
        OMG()
        print("reading file error")
        return 2
    
    if readint(bytes, 0) != int(asig,16): #check if file is signed
        OMG()
        print("wrong file signature")
        return 3
    
    if readint(bytes, 4) != aver: #check file version
        OMG()
        print("wrong file version")
        return 4
    
    #reading mesh information
    nfaces = readint(bytes, 8)
    nverts = readint(bytes, 12)
    vblocksize = readint(bytes, 16)
    ntextures = readint(bytes, 20)
    nshaders = readint(bytes, 24)
    nattr = readint(bytes, 28)
    
    print("Mesh contains:     ")
    print("Faces:             " + str(nfaces))
    print("Verts:             " + str(nverts))
    print("Textures:          " + str(ntextures))
    print("Shaders:           " + str(nshaders))
    print("Data formatting    ")
    print("Blocksize:         " + str(vblocksize))
    print("Attributes/Vertex: " + str(nattr))
    
    attributes = [[[] for j in range(nattr)] for i in range(6)]
    pointer = 32
    
    for i in range(len(attributes[0])):
        attributes[0][i] = readstring(bytes, pointer) #read name
        pointer = next0(bytes, pointer)+1
        attributes[1][i] = readint(bytes, pointer) #read index
        pointer += 4
        attributes[2][i] = readint(bytes, pointer) #read offset
        pointer += 4
        attributes[3][i] = readint(bytes, pointer) #read size
        pointer += 4
        attributes[4][i] = readint(bytes, pointer) #read elements count
        pointer += 4
        t = []
        j = 0
        for j in range(attributes[4][i]): # read types
            t.append(readint(bytes, pointer))
            pointer += 4
        attributes[5][i] = t
    print("Attributes:\n" + str(attributes))
    
    for i in range(ntextures): # read textures
        textures.append(readstring(bytes,pointer))
        pointer = next0(bytes, pointer)+1
    
    for i in range(nfaces): # read faces
        faces.append((
            readint(bytes, pointer),
            readint(bytes, pointer + 4),
            readint(bytes, pointer + 8)
        ))
        pointer += 12
    
    vdata = [[]for i in range(len(attributes[0]))]
    
    for i in range(nverts): # vertices
        for j in range(len(vdata)): # attributes
            d = []
            for k in range(attributes[4][j]): #values
                if(attributes[5][j][k] == 0):
                    d.append(readfloat(bytes, pointer))
                    pointer +=4
                if(attributes[5][j][k] == 1):
                    d.append(readint(bytes, pointer))
                    pointer +=4
                #more read 
            vdata[j].append(tuple(d))
    print("reading data ended pointing at byte: " + str(pointer))
    
    #processing vertex data
    for i in range(len(vdata)):
        if(attributes[0][i] == spos and attributes[1][i] == 0): #check for position data
            vertex_position = vdata[i]
        if(attributes[0][i] == snorm and attributes[1][i] == 0): #check for norm data
            vertex_normal = vdata[i]
    print(len(vdata[0][0]))
    
    #creating mesh and object
    me = bpy.data.meshes.new(object_name)
    ob = bpy.data.objects.new(object_name, me)
    ob.location = bpy.context.scene.cursor_location
    bpy.context.scene.objects.link(ob)
    bpy.context.scene.objects.active = ob
    ob.select = True
    me.from_pydata(vertex_position, [], faces)
    me.update(calc_edges = True)
    return 1

#################  MAIN  #######################
if __name__ == "__main__":
    print("#######################")
    print("## RIP FILE IMPORTER ##\nfor ninjaripper 1.3.3\n")
    flist = os.listdir(dir)
    for file in flist:
        fstr = str(file)
        if file.startswith("Mesh_") and file.endswith(".rip"):
            oname = fstr[0:fstr.index('.')]
            print("Importing: " + fstr + "...\n")
            try:
                a = import_ninja_rip(filename = dir + fstr, object_name = oname)
                print("Imported: " + fstr + " to object: " + oname + ".\n")
            except Exception as e:
                OMG()
    print("done with doing stuff")
